\chapter{Platform}
\label{chap:platform}

$Crowdy$ is an extensible general-purpose crowdsourcing platform to solve 
complex problems. The platform is developed over the fundamentals of stream 
processing paradigm in which a series of operations are applied to the continuous 
stream of data elements via operators.

$Crowdy$ is an operator-centric platform. Using this platform, a requester with no 
requirement of programming background can quickly translate a complex problem into 
a crowdsourcing application by simply selecting operators and connecting these operators 
together. Thanks to $Crowdy$'s focus on operators, requesters can design applications 
by selecting right set of building blocks that are necessary to solve a complex problem 
and customizing these blocks particular to the computation to-be-conducted.

$Crowdy$ embodies several features:
\begin{itemize}
	\item A standard toolkit of operators that can employ computation resources 
	(human or software) to accomplish various tasks
	\item Configuration support to design coordination of computation resources 
	over operators
	\item Operator parameterization and customization for support of customizable 
	collaborations
	\item Application runtime interface
\end{itemize}

In the remainder of this chapter, the fundamental concepts of $Crowdy$ are explained 
in more detail and features are explored as we look into various aspects of application 
development using $Crowdy$ platform.

\section{A "Hello World" application}
$Crowdy$ applications are developed to solve complex and sophisticated problems 
that require both human intelligence and computing power. A typical application contains 
three main high-level components: data ingest, processing and data egress.

Let's consider a minimal "Hello World" application that has these three components 
in total, connected in a simple pipeline topology. Figure~\ref{fig:hello world} demonstrates 
the application in the form of a flow graph. On the ingest side, there is a 
\textit{source operator}, which, acts like a data generator. Source operator produces 
data tuples that are processed down the flow by the 
\textit{processing operator}. Finally, the \textit{sink operator} simply converts the tuples 
in such a form (text file, email etc) that can be easily interpreted by requesters.

The application flow graph is specified as a series of operator instances and connections 
(data flows) that link them. A data flow basically transfers data tuples 
produced by an operator to another. One or more data segments can be assembled in a 
data tuple via output specification of operator instance. In addition, several options can 
be specified to configure operator instance. These include parameters, operator-specific 
rules, which is studied in the rest of this chapter.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.85\textwidth]{figures/helloworld.png}
	\caption{A sample, minimal $Crowdy$ application.}
	\label{fig:hello world}
\end{figure}

In a more realistic application, one or more source operators can be employed to produce 
various data tuples that differ in both size and specification. Similarly, the application would 
have one or more processing operators along with other types of operators organized in a way 
that is significantly more complex than this example.

\section{Operator}
An operator is the basic building block of an application. As soon as an operator is created, 
a unique ID is generated and assigned to it. Operator has a type that is specified at the time of 
creation, and type determines configuration respectively. In addition, operator has optional 
name and description fields that can be used for bookkeeping purposes.

Operator may have an input port or output port or both corresponding to it's type 
definition. Figure~\ref{fig:basic operator} demonstrates a base operator, which 
consists of a body and ports. Although it is not shown here, each operator presentation 
has a specific icon on their body associated to it's type.

\begin{figure}[ht]
	\centering
	\includegraphics[height=100px]{figures/basicoperator.pdf}
	\caption{Base operator representation.}
	\label{fig:basic operator}
\end{figure}

$Crowdy$ provides a set of built-in operators that can be used to build applications. 
In general, these operators perform common tasks associated with data generation, 
processing and outputting and are generally cross-domain. These operators can be 
grouped into six main categories: \textit{source, sink, processing, relational, utility, adapter}.

\subsection{Source operators}
The set of source operators generates data tuples. These operators do not have 
an input port, but have an output port, which outputs data tuples. Figure~\ref{fig:source operator} 
represents a source operator.

\begin{figure}[ht]
	\centering
	\includegraphics[height=60px]{figures/SourceOperator.pdf}
	\caption{Source operator representation.}
	\label{fig:source operator}
\end{figure}

Source operators together with processing operators are the ones that can be 
used to specify data flow coming out of an operator. Output specification is an 
action to identify the data tuple with a series of segments. Other operator types 
cannot make changes on output specification, but manipulate the flow by dropping 
or copying data tuples.

\textbf{human.} 
The \textit{human source operator} is a stateless operator used to produce new data tuples 
via human workers. Existing crowdsourcing services such as MTurk is used 
to produce new tuples over the results retrieved from human intelligent tasks. These 
tasks are automatically created and posted with respect to the specified parameters 
of the operator.

Human source operator has the following parameters:
\begin{itemize}
	\item \texttt{number of copies}: The maximum number of data tuples can be 
	generated by the operator. It's value ranges from 1 to 1000.
	\item \texttt{max allotted time}: The maximum time in seconds given to a human 
	worker to solve and submit the task. It's value ranges from 10 to 300.
	\item \texttt{payment}: The payment in cents to be given to the human worker in 
	case of successful task completion. It's value ranges from 5 to 500.
	\item \texttt{instructions}: The detailed information for human workers on how to 
	complete the task.
	\item \texttt{question}: The actual sentence asking for specific information.
	\item \texttt{input list}: The list of \texttt{input}s that will be shown to human worker to fill.
\end{itemize}

An \texttt{input} can be a type of \textit{text, number, single choice} or 
\textit{multiple choice}. A text-input presents an input field where the human worker can 
enter data. The maximum number of characters that can be entered to the field can be 
set by the requester. Similarly number-input corresponds to a input field where only 
numbers can be fed in, and the maximum and minimum value for the field are set by 
the requester. The other two input types conform to input fields where the options given 
by the requester are presented to the human worker as a list. Human worker is expected 
to select only one and one or more options for single choice and multiple choice types 
respectively.

%This operator has a significant role in the platform. 
% platform-independence, abstracts away the details of the underlying platform
% use results of other operators
% customize collaboration by specifying audience

\textbf{manual.}
The \textit{manual source operator} is a stateless operator to produce new data 
tuples. However, this operator uses manually entered text to create new tuples. Operator 
retrieves the manual text, parses it line by line and then applies delimiter if selected. 
Therefore, each line constitutes a data tuple, and delimiter is used to create segments 
within a tuple.

Manual source operator has the following parameters:
\begin{itemize}
	\item \texttt{manual entry}: The manual text to be parsed and used to produce 
	new tuples.
	\item \texttt{delimiter}: Delimiter to determine segments in a tuple. This can be one 
	of the following values: none, white space, tab, comma, column.
\end{itemize}

\subsection{Sink operators}
The set of sink operators is where data tuples are serialized and converted into formats 
that can be used by requesters with ease. These operators has one input port, but no 
output port. Figure \ref{fig:sink operator} demonstrates a sink operator.

\begin{figure}[ht]
	\centering
	\includegraphics[height=60px]{figures/SinkOperator.pdf}
	\caption{Sink operator representation.}
	\label{fig:sink operator}
\end{figure}

\textbf{email.}
The \textit{email sink operator} is a stateless operator to convert data tuples into a 
text format and email them to requesters. \texttt{email} parameter specifies the 
requester's email address. 

\textbf{file.}
The \textit{file sink operator} is a stateless operator to serialize the data tuples into 
a file. Operator has one parameter \texttt{filename} that is used to specify the name 
of file in which tuples will be written.

\subsection{Processing operators}
The set of processing operators provides data tuple processing via human workers. 
These operators have both input and output ports. Figure \ref{fig:processing operator} shows 
a processing operator.

\begin{figure}[ht]
	\centering
	\includegraphics[height=60px]{figures/ProcessingOperator.pdf}
	\caption{Processing operator representation.}
	\label{fig:processing operator}
\end{figure}

As mentioned before, processing operators can manipulate the data flow specification 
in addition to source operators. These operators can change the existing flow specification 
by adding, deleting or editing data segments.

\textbf{human.}
The \texttt{human processing operator} is almost same as human source operator. 
The difference is that human processing operator has an input port. So there is a 
flow of data tuples coming to the operator. These incoming tuples are made available 
to requesters via their specification. Therefore, requesters can create an information 
flow from one operator to another.

The parameters of human processing operator is no different than the parameters of 
human source operator. However, requesters can use incoming data in 
\texttt{instructions}, \texttt{question} and \texttt{input list} (applicable to single choice 
and multiple choice inputs). Available data segments of incoming flow can be placed 
in these parameters to create human tasks that are handled dynamically.

\subsection{Relational operators}
The set of relational operators enables fundamental manipulation operations on 
the flow of data tuples. These operators have both input and output port. Each of 
these operators implements a specific functionality providing continuous and 
non-blocking processing on tuples.

\textbf{selection.}
The \textit{selection operator} is a stateless operator used to filter tuples. A typical 
selection operator is shown in Figure~\ref{fig:selection operator}.

\begin{figure}[ht]
	\centering
	\includegraphics[height=60px]{figures/SelectionOperator.pdf}
	\caption{Selection operator representation.}
	\label{fig:selection operator}
\end{figure}

On a per-tuple basis a boolean predicate is evaluated and a decision is made as 
to whether to filter the corresponding tuple or not. Boolean predicates are specified 
by requesters as part of operator parametrization. These predicates share the 
predefined format explained in the following:

[Explanation]

[Code format]

\textbf{sort.}
The \textit{sort operator} is a stateful and windowed operator used to first group 
tuples and then sort them based on the specified data segment and order. Figure
~\ref{fig:sort operator} illustrates the operator.

\begin{figure}[ht]
	\centering
	\includegraphics[height=60px]{figures/SortOperator.pdf}
	\caption{Sort operator representation.}
	\label{fig:sort operator}
\end{figure}

Sorting is performed and results are produced (outputted one by one) every time 
window trigger policy fires. The policy is triggered when the number of data tuples 
reaches \texttt{window size}, which is a parameter. 

\subsection{Utility operators}
TODO

\textbf{enrich.}
\begin{figure}[ht]
	\centering
	\includegraphics[height=60px]{figures/EnrichOperator.pdf}
	\caption{Enrich operator representation.}
	\label{fig:enrichoperator}
\end{figure}

\textbf{split.}
\begin{figure}[ht]
	\centering
	\includegraphics[height=60px]{figures/SplitOperator.pdf}
	\caption{Split operator representation.}
	\label{fig:splitoperator}
\end{figure}

\textbf{union.}
The \textit{union operator} is a stateless operator used to join two or more data flow 
into one.

\begin{figure}[ht]
	\centering
	\includegraphics[height=60px]{figures/UnionOperator.pdf}
	\caption{Union operator representation.}
	\label{fig:unionoperator}
\end{figure}

\section{Flow compositon}
TODO